name:     app-lens
version:  0.1.0.0
synopsis: applicative (functional) bidirectional programming that beyonds composition chains 

description:
   A bidirectional transformation connects data in difference sources,
   maintaining consistency amid separate updates. The "lens"
   programming language---the most famous implementation in Haskell
   would be the Kmett's 'lens' package---is a solution to this
   problem.
   .
   However, in programming with lenses, we have to stick to the
   point-free style of programming. Although the point-free style is
   sometimes concise, and suitable for record-access chains as lens
   provide, it is sometimes difficult to manage when we write
   non-small programs.
   . 
   This library provides a way to represent (n-ary) lenses as (n-ary)
   functions, which enables us to compose lenses as usual functions.
   For example, let us consider 'unlines' functions and how to define
   a 'lens' version of it, assuming that we already have a lens
   @catLineL :: Lens' (String, String) String@ that concatenates
   two strings with a newline in the middle. In our framework, this
   example can be written by using the usual pattern matching and
   recursion, as follows.
   .
   @
   unlinesF :: [L s String] -> L s String
   unlinesF []     = new ""
   unlinesF (x:xs) = catLineF x (unlinesF xs)
      where catLineF = lift2 catLineL
   @
   .   
   Here, @lift2 :: Lens' (a,b) c -> (forall s. L s a -> L s b -> L s
   c)@ and @new :: a -> (forall s. L s a)@ lift lenses to functions.
   The former is for binary lenses and the latter is for constants.
   Thanks to these lifting functions, we can compose lenses as they
   are functions because they actually are functions. Thus, we can
   freely use variables (such as @x@ and @xs@ above) to bind sources
   and targets of lenses, and higher-order functions. That is, we can
   use an applicative-style (i.e., an usual functional style) to
   compose lenses.
   .
   To make a lens from such lifted "lens functions", use unlifting
   functions ('unlift', 'unlift2', 'unliftT') as follows.
   .   
   @
   unlinesL :: Lens' [String] String
   unlinesL = unliftT unlinesF
   @
   .
   The obtained lens works as follows.
   .
   >>> ["banana", "orange", "apple"] ^. unlinesL
   "banana\norange\napple\n"
   >>> ["banana", "orange", "apple"] & unlinesL .~ "Banana\nOrange\nApple\n"
   ["Banana","Orange","Apple"]
   . 
   Other examples can be found at "Examples" in the source code
   <https://bitbucket.org/kztk/app-lens/downloads>.
   ==== Remark
   .
   One of the characteristics of the lens package is that one can
   write a bidirectional programming as a record-field access chain.
   For example, given lenses @l1 :: Lens' A B@ and @l2 :: Lens' B C@,
   one can write forward (or, "getting") and backward (or "putting
   back") transformations.  as follows.
   .
   @
   src .^ l1 . l2 
   src & l1 . l2 .~ tgt' 
   @
   . 
   This kind of programming is also possible in our framework, but 
   the order composition must be inverted. 
   .
   @
   src .^ unlift (lift l2 . lift l1)
   src & unlift (lift l2 . lift l1) .~ tgt' 
   @
   . 
   Although this situation could be easily recovered by using some
   extra combinators, this is not the aim of our framework and our
   framework does not provide any combinators. 
   


license:             BSD3
license-file:        LICENSE

homepage:            https://bitbucket.org/kztk/app-lens
bug-reports:         https://bitbucket.org/kztk/app-lens/issues
tested-with:         GHC == 7.8.3


author:              Kazutaka Matsuda
copyright:           (c) Kazutaka Matsuda, 2015
maintainer:          kztk@ecei.tohoku.ac.jp
category:            Data, Lenses
build-type:          Simple
cabal-version:       >=1.10



Flag UseVanLaarhoven
  Description: Use Control.Lens.Lens' as internal representations.
  Default:     False 

Library
  exposed-modules:
    Control.LensFunction, 
    Control.LensFunction.Exception
  
  other-modules: 
    Control.LensFunction.Core, 
    Control.LensFunction.Util 
    Control.LensFunction.Internal    
  
  if flag(useVanLaarhoven)
    other-modules: Control.LensFunction.InternalL
    cpp-options: -D__USE_VAN_LAARHOVEN__

  other-extensions:    
    RankNTypes, NoMonomorphismRestriction, 
    FlexibleInstances, FlexibleContexts, UndecidableInstances, 
    IncoherentInstances, CPP, ExistentialQuantification, 
    DeriveDataTypeable, DeriveFunctor, DeriveFoldable, DeriveTraversable
  
  build-depends:  
    base       >=4.7   && < 4.8, 
    containers >=0.5   && < 0.6, 
    mtl        >=2.2   && < 2.3,
    lens       >=4     && < 4.12
  
  ghc-prof-options: -prof -auto-all -rtsopts 

  default-language: Haskell2010

-- Executable prof
--   Main-is: Bench/Prof.hs
--   Build-Depends:
--      app-lens, 
--      base,
--      mtl, 
--      containers, 
--      lens, 
--      deepseq >= 1.3 && < 2, 
--      criterion >= 1.1 && < 2
--
--
--   if flag(useVanLaarhoven)
--     cpp-options: -D__USE_VAN_LAARHOVEN__
--
--   ghc-options: -O2 -rtsopts 
--   ghc-prof-options: -prof -auto-all -rtsopts "-with-rtsopts=-p -s"
--   default-language:    Haskell2010


Benchmark compositions
  type: exitcode-stdio-1.0
  Main-is: Bench/Compositions.hs
  Build-Depends: 
     app-lens, 
     base,
     mtl, 
     containers, 
     lens, 
     deepseq >= 1.3 && < 1.4, 
     criterion >= 1.1 && < 1.2


  if flag(useVanLaarhoven)
    cpp-options: -D__USE_VAN_LAARHOVEN__

  ghc-options: -rtsopts 
  ghc-prof-options: -prof -auto-all -rtsopts 
  default-language:    Haskell2010

Benchmark eval
  type: exitcode-stdio-1.0
  Main-is: Bench/Eval.hs
  Build-Depends: 
     app-lens, 
     base,
     mtl, 
     containers, 
     lens,
     deepseq >= 1.3 && < 1.4, 
     criterion >= 1.1 && < 1.2

  other-modules: 
     Examples.Evaluator

  if flag(useVanLaarhoven)
    cpp-options: -D__USE_VAN_LAARHOVEN__

  ghc-options: -rtsopts 
  ghc-prof-options: -prof -auto-all -rtsopts 
  default-language:    Haskell2010

source-repository head
   type:     git
   location: https://bitbucket.org/kztk/app-lens



